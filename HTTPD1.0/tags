!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
BUFFER_SIZE	cgi.h	/^    static const int BUFFER_SIZE = 1024;$/;"	m	class:cgi_conn
BUFFER_SIZE	cpy_cgi.cpp	/^    static const int BUFFER_SIZE = 1024;$/;"	m	class:cgi_conn	file:
BUFFER_SIZE	cpy_cgi.h	/^    static const int BUFFER_SIZE = 1024;$/;"	m	class:cgi_conn
BUFFER_SIZE	test.cpp	/^    static const int BUFFER_SIZE = 1024;$/;"	m	class:cgi_conn	file:
GET	cpy_cgi.cpp	/^    GET = 1,$/;"	e	enum:Method_t	file:
GET	cpy_cgi.h	/^    GET = 1,$/;"	e	enum:Method_t
MAX_EVENT_NUMBER	processpool.h	/^    static const int MAX_EVENT_NUMBER = 10000;$/;"	m	class:processpool
MAX_PROCESS_NUMBER	processpool.h	/^    static const int MAX_PROCESS_NUMBER = 16;$/;"	m	class:processpool
Method	cpy_cgi.cpp	/^typedef enum Method_t Method;$/;"	t	typeref:enum:Method_t	file:
Method	cpy_cgi.h	/^typedef enum Method_t Method;$/;"	t	typeref:enum:Method_t
Method_t	cpy_cgi.cpp	/^enum Method_t {$/;"	g	file:
Method_t	cpy_cgi.h	/^enum Method_t {$/;"	g
OTHER	cpy_cgi.cpp	/^    OTHER$/;"	e	enum:Method_t	file:
OTHER	cpy_cgi.h	/^    OTHER$/;"	e	enum:Method_t
POST	cpy_cgi.cpp	/^    POST,$/;"	e	enum:Method_t	file:
POST	cpy_cgi.h	/^    POST,$/;"	e	enum:Method_t
SERVER_STRING	cpy_cgi.cpp	20;"	d	file:
USER_PRE_PROCESS	processpool.h	/^    static const int USER_PRE_PROCESS = 65535;$/;"	m	class:processpool
__LOCKER_H__	locker.h	2;"	d
__PROCESSPOOL_H__	processpool.h	2;"	d
addfd	processpool.h	/^static void addfd(int epollfd, int fd)$/;"	f
addsig	processpool.h	/^static void addsig(int sig, void(handler)(int), bool restart = true)$/;"	f
cannot_execute	cpy_cgi.cpp	/^void cannot_execute(int client)$/;"	f
cgi_conn	cgi.h	/^    cgi_conn(){}$/;"	f	class:cgi_conn
cgi_conn	cgi.h	/^class cgi_conn {$/;"	c
cgi_conn	cpy_cgi.cpp	/^    cgi_conn(){}$/;"	f	class:cgi_conn
cgi_conn	cpy_cgi.cpp	/^class cgi_conn {$/;"	c	file:
cgi_conn	cpy_cgi.h	/^    cgi_conn(){}$/;"	f	class:cgi_conn
cgi_conn	cpy_cgi.h	/^class cgi_conn {$/;"	c
cgi_conn	test.cpp	/^    cgi_conn(){}$/;"	f	class:cgi_conn
cgi_conn	test.cpp	/^class cgi_conn {$/;"	c	file:
cond	locker.h	/^    cond()$/;"	f	class:cond
cond	locker.h	/^class cond{$/;"	c
create	processpool.h	/^    static processpool< T > * create( int listenfd, int process_number = 8 )$/;"	f	class:processpool
drop_header	cpy_cgi.cpp	/^void drop_header(int sockfd)$/;"	f
echo_www	cpy_cgi.cpp	/^    void echo_www(const char * file, size_t size)$/;"	f	class:cgi_conn	file:
exec_cgi	cpy_cgi.cpp	/^    void  exec_cgi(int sockfd = m_sockfd, const char* method, const char* query_string, const char* path)$/;"	f	class:cgi_conn	file:
get_line	cpy_cgi.cpp	/^static int get_line(int sockfd, char* line, int size)$/;"	f	file:
get_method	cpy_cgi.cpp	/^    void get_method(std::string& str)$/;"	f	class:cgi_conn	file:
get_method	cpy_cgi.h	/^    void get_method(std::string& str)$/;"	f	class:cgi_conn
headers	cpy_cgi.cpp	/^void headers(int client)$/;"	f
init	cgi.h	/^    void init( int epollfd, int sockfd, const struct sockaddr_in& client )$/;"	f	class:cgi_conn
init	cpy_cgi.cpp	/^    void init( int epollfd, int sockfd, const struct sockaddr_in& client )$/;"	f	class:cgi_conn
init	cpy_cgi.h	/^    void init( int epollfd, int sockfd, const struct sockaddr_in& client )$/;"	f	class:cgi_conn
init	test.cpp	/^    void init( int epollfd, int sockfd, const struct sockaddr_in& client )$/;"	f	class:cgi_conn
lock	locker.h	/^    bool lock()$/;"	f	class:locker
locker	locker.h	/^    locker()$/;"	f	class:locker
locker	locker.h	/^class locker{$/;"	c
m_address	cgi.h	/^    sockaddr_in m_address;$/;"	m	class:cgi_conn
m_address	cpy_cgi.cpp	/^    sockaddr_in m_address;$/;"	m	class:cgi_conn	file:
m_address	cpy_cgi.h	/^    sockaddr_in m_address;$/;"	m	class:cgi_conn
m_address	test.cpp	/^    sockaddr_in m_address;$/;"	m	class:cgi_conn	file:
m_buf	cgi.h	/^    char m_buf[BUFFER_SIZE];$/;"	m	class:cgi_conn
m_buf	cpy_cgi.cpp	/^    char m_buf[BUFFER_SIZE];$/;"	m	class:cgi_conn	file:
m_buf	cpy_cgi.h	/^    char m_buf[BUFFER_SIZE];$/;"	m	class:cgi_conn
m_buf	test.cpp	/^    char m_buf[BUFFER_SIZE];$/;"	m	class:cgi_conn	file:
m_cgi	cpy_cgi.cpp	/^    bool m_cgi;$/;"	m	class:cgi_conn	file:
m_cond	locker.h	/^    pthread_cond_t m_cond;$/;"	m	class:cond
m_epollfd	cgi.h	/^    static int m_epollfd;$/;"	m	class:cgi_conn
m_epollfd	cpy_cgi.cpp	/^    int m_epollfd;$/;"	m	class:cgi_conn	file:
m_epollfd	cpy_cgi.h	/^    int m_epollfd;$/;"	m	class:cgi_conn
m_epollfd	processpool.h	/^    int m_epollfd;$/;"	m	class:processpool
m_epollfd	test.cpp	/^    int m_epollfd;$/;"	m	class:cgi_conn	file:
m_file	cpy_cgi.cpp	/^    std::string m_file;$/;"	m	class:cgi_conn	file:
m_file	cpy_cgi.h	/^    std::string m_file;$/;"	m	class:cgi_conn
m_idx	processpool.h	/^    int m_idx;$/;"	m	class:processpool
m_instance	processpool.h	/^    static processpool< T > * m_instance;$/;"	m	class:processpool
m_instance	processpool.h	/^processpool< T > * processpool< T >::m_instance = NULL;$/;"	m	class:processpool
m_listenfd	processpool.h	/^    int m_listenfd;$/;"	m	class:processpool
m_method	cpy_cgi.cpp	/^    Method m_method;$/;"	m	class:cgi_conn	file:
m_method	cpy_cgi.h	/^    Method m_method;$/;"	m	class:cgi_conn
m_mutex	locker.h	/^    pthread_mutex_t m_mutex;$/;"	m	class:cond
m_mutex	locker.h	/^    pthread_mutex_t m_mutex;$/;"	m	class:locker
m_pid	processpool.h	/^    pid_t m_pid;$/;"	m	class:process
m_pipefd	processpool.h	/^    int m_pipefd[2];$/;"	m	class:process
m_process_number	processpool.h	/^    int m_process_number;$/;"	m	class:processpool
m_querystring	cpy_cgi.cpp	/^    std::string m_querystring;$/;"	m	class:cgi_conn	file:
m_read_idx	cgi.h	/^    int m_read_idx;$/;"	m	class:cgi_conn
m_read_idx	cpy_cgi.cpp	/^    int m_read_idx;$/;"	m	class:cgi_conn	file:
m_read_idx	cpy_cgi.h	/^    int m_read_idx;$/;"	m	class:cgi_conn
m_read_idx	test.cpp	/^    int m_read_idx;$/;"	m	class:cgi_conn	file:
m_sem	locker.h	/^    sem_t m_sem;$/;"	m	class:sem
m_sockfd	cgi.h	/^    static int m_sockfd;$/;"	m	class:cgi_conn
m_sockfd	cpy_cgi.cpp	/^    int m_sockfd;$/;"	m	class:cgi_conn	file:
m_sockfd	cpy_cgi.h	/^    int m_sockfd;$/;"	m	class:cgi_conn
m_sockfd	test.cpp	/^    int m_sockfd;$/;"	m	class:cgi_conn	file:
m_stop	processpool.h	/^    int m_stop;$/;"	m	class:processpool
m_sub_process	processpool.h	/^    process * m_sub_process;$/;"	m	class:processpool
main	cpy_cgi.cpp	/^int main( int argc, char * argv[] )$/;"	f
main	cpy_cgi.h	/^int main( int argc, char * argv[] )$/;"	f
main	test.cpp	/^int main( int argc, char * argv[] )$/;"	f
not_found	cpy_cgi.cpp	/^void not_found(int client)$/;"	f
post	locker.h	/^    bool post()$/;"	f	class:sem
process	cgi.h	/^    void process()$/;"	f	class:cgi_conn
process	cpy_cgi.cpp	/^    void process()$/;"	f	class:cgi_conn
process	cpy_cgi.h	/^    void process()$/;"	f	class:cgi_conn
process	processpool.h	/^    process():m_pid(-1) {}$/;"	f	class:process
process	processpool.h	/^class process {$/;"	c
process	test.cpp	/^    void process()$/;"	f	class:cgi_conn
processpool	processpool.h	/^class processpool {$/;"	c
processpool	processpool.h	/^processpool< T >::processpool(int listenfd, int process_number)$/;"	f	class:processpool
removefd	processpool.h	/^static void removefd(int epollfd, int fd)$/;"	f
run	processpool.h	/^void processpool< T >::run()$/;"	f	class:processpool
run_child	processpool.h	/^void processpool< T >::run_child()$/;"	f	class:processpool
run_parent	processpool.h	/^void processpool< T >::run_parent()$/;"	f	class:processpool
sem	locker.h	/^    sem()$/;"	f	class:sem
sem	locker.h	/^class sem{$/;"	c
setnoblocking	processpool.h	/^static int setnoblocking(int fd)$/;"	f
setup_sig_pipe	processpool.h	/^void processpool< T >::setup_sig_pipe()$/;"	f	class:processpool
sig_headler	processpool.h	/^static void sig_headler(int sig)$/;"	f
sig_pipefd	processpool.h	/^static int sig_pipefd[2];$/;"	v
signal	locker.h	/^    bool signal()$/;"	f	class:cond
start_up	cpy_cgi.cpp	/^int start_up(const char * ip, int port)$/;"	f
start_up	cpy_cgi.h	/^int start_up(const char * ip, int port)$/;"	f
start_up	test.cpp	/^int start_up(const char * ip, int port)$/;"	f
unlock	locker.h	/^    bool unlock()$/;"	f	class:locker
usage	cpy_cgi.cpp	/^void usage(const char * arg)$/;"	f
usage	cpy_cgi.h	/^void usage(const char * arg)$/;"	f
usage	test.cpp	/^void usage(const char * arg)$/;"	f
wait	locker.h	/^    bool wait()$/;"	f	class:cond
wait	locker.h	/^    bool wait()$/;"	f	class:sem
~cgi_conn	cgi.h	/^    ~cgi_conn(){}$/;"	f	class:cgi_conn
~cgi_conn	cpy_cgi.cpp	/^    ~cgi_conn(){}$/;"	f	class:cgi_conn
~cgi_conn	cpy_cgi.h	/^    ~cgi_conn(){}$/;"	f	class:cgi_conn
~cgi_conn	test.cpp	/^    ~cgi_conn(){}$/;"	f	class:cgi_conn
~cond	locker.h	/^    ~cond()$/;"	f	class:cond
~locker	locker.h	/^    ~locker()$/;"	f	class:locker
~processpool	processpool.h	/^    ~processpool()$/;"	f	class:processpool
~sem	locker.h	/^    ~sem()$/;"	f	class:sem
